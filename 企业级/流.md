流（stream）是编程中处理 流式数据 的 抽象 接口。

Node.js中 stream 模块用于构建实现了 流 接口的对象。

例如：HTTP服务器的请求 和 process.stdout 都是流的实例。

流可以是可读的，可写的或可读可写的。所有的流都是 EventEmitter 的实例。

流的使用方法如下：

const stream = require('stream');

## 流的类型

4种基本的流类型

可读流（Writble): 可写入数据的流，如： fs.createWriteStream()。

可写流（Readable): 可读取数据的流，如： fs.createReadStream()。

双工流（Duplex): 可读又可写的流，如 net.Socket

转换流（Transform): 在读写过程中可以修改或转换数据的Duplex流，如 zlib.createDeflate().

## 对象模式

当创建流的时候，可以使用 objectMode 选项把流实例 切换到对象模式，将已存在的流切换到对象模型是不安全的。

## 流中的缓冲区

可写流 和 可读流都会在内部的缓冲区中存储数据，可以分别使用 writable.writableBuffer 或 readable.readableBuffer 来获取。

可缓冲的数据大小取决于传入流构造函数的 highWaterMark 选项。 对于普通的流， highWaterMark 指定流子节的总数。

对于对象模式的流，highWaterMark 指定流对象的总数。

当调用 stream.push(chunk) 时，数据会被缓冲在可读流中。如果流的 “消费者” 没有调用 stream.read()，则数据会保留在 内部队列 中直到被消费。

一旦内部的可读缓冲的总大小达到 highWaterMark 指定的 阀值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费（也就是说，流会停止调用内部的用于填充可读缓冲的 readable._read()

当调用 writable.write(chunk) 时，数据会被缓冲在可写流中。

当内部的可写缓冲的总大小 小于 hightWaterMark 设置的阀值时， 调用 writable.write() 会返回 true。一旦内部缓冲的大小达到或超过 highWaterMark 时，则会返回 false。

为了保存内存，某些 Stream API 会限制缓冲区，可以避免读写速度不一致引起的内存的崩溃。

## 可读流

所有可读流都实现了 stream.Readable 类定义的接口。

类事件

close 事件在流或其底层资源被关闭时触发。

data 事件











