流（stream）是编程中处理 流式数据 的 抽象 接口。

Node.js中 stream 模块用于构建实现了 流 接口的对象。

例如：HTTP服务器的请求 和 process.stdout 都是流的实例。

流可以是可读的，可写的或可读可写的。所有的流都是 EventEmitter 的实例。

流的使用方法如下：

const stream = require('stream');

## 流的类型

4种基本的流类型

可读流（Writble): 可写入数据的流，如： fs.createWriteStream()。

可写流（Readable): 可读取数据的流，如： fs.createReadStream()。

双工流（Duplex): 可读又可写的流，如 net.Socket

转换流（Transform): 在读写过程中可以修改或转换数据的Duplex流，如 zlib.createDeflate().

## 对象模式

当创建流的时候，可以使用 objectMode 选项把流实例 切换到对象模式，将已存在的流切换到对象模型是不安全的。

## 流中的缓冲区

可写流 和 可读流都会在内部的缓冲区中存储数据，可以分别使用 writable.writableBuffer 或 readable.readableBuffer 来获取。

可缓冲的数据大小取决于传入流构造函数的 highWaterMark 选项。 对于普通的流， highWaterMark 指定流子节的总数。

对于对象模式的流，highWaterMark 指定流对象的总数。

当调用 stream.push(chunk) 时，数据会被缓冲在可读流中。如果流的 “消费者” 没有调用 stream.read()，则数据会保留在 内部队列 中直到被消费。

一旦内部的可读缓冲的总大小达到 highWaterMark 指定的 阀值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费（也就是说，流会停止调用内部的用于填充可读缓冲的 readable._read()

当调用 writable.write(chunk) 时，数据会被缓冲在可写流中。

当内部的可写缓冲的总大小 小于 hightWaterMark 设置的阀值时， 调用 writable.write() 会返回 true。一旦内部缓冲的大小达到或超过 highWaterMark 时，则会返回 false。

为了保存内存，某些 Stream API 会限制缓冲区，可以避免读写速度不一致引起的内存的崩溃。

## 可读流

所有可读流都实现了 stream.Readable 类定义的接口。

Node.js可读流是对提供数据的来源的一种抽象。所有可读流都实现了stream.Readable类定义的接口。可读流常见的例子包括客户端的HTTP响应，服务器的HTTP请求，fs的读取流，zlib流，crypto流，TCP socket，子进程stdout与stderr, process.stdin.

## stream.Readable 类事件

stream.Readable 类定义了如下事件。

1. close事件

close事件在流或其底层资源（如文件描述符）被关闭时触发。表明不会再触发其他事件，也不会再发生操作。

不是所有可读流都会触发close事件。如果使用emitClose选项创建可读流，则它将始终发出close事件。

2. data事件

data事件是在流将数据块传送给“消费者”后触发。对于非对象模式的流，数据块可以是字符串或Buffer。对于对象模式的流，数据块可以是除了null的任何JavaScript值。

当调用 readable.pipe(), readable.resume() 或绑定监听器到 data 事件时，流会转换到流动模式。当调用 readable.read()且有数据块返回时，也会触发data事件。

如果使用 readable.setEncoding() 为流指定 🈯️ 了默认的字符编码，则监听器回调传入的数据为字符串，否则传入的数据为Buffer。


3. end事件

end 事件在流中没有数据可供消费时触发。

end 事件只有在你数据被完全消费掉后才会触发。要想触发该事件，可以将流转换到流动模式，或反复调用 stream.read() 直到数据被消费完。

```js
const readable = getReadableStreamSomehow();

readable.on('data', (chunk) => {
 console.log(`接收到${chunk.length}个字节的数据`);
});

readable.on('end', () => {
 console.log(`已经没有数据`);
});
```

4. error事件

error事件通常是在当流因底层内部出错而不能产生数据，或推送无效的数据块时触发。

监听器回调将传递一个Error对象

5. pause事件

调用 stream.pause() 并且 readsFlowing 不为 false时，会发出pause事件。

6. readable事件

readable事件在当流中有数据可供读取时触发。

```js
const readable = getReadableStreamSomehow();

readable.on('readable', function() {
 // 有数据可读取
 let data;
 while(data = this.read()) {
  console.log(data);
 }
});
```

当到达流数据的尽头时，readable事件也会触发，但是在end事件之前触发。

readable 事件表明流有新的动态，要么有新的数据，要么到达流的尽头。对于前者，stream.read() 会返回可用的数据。对于后者，stream.read() 会返回 null 。 例如，下面的例子中，foo.txt是一个空文件。

```js
const fs = require('fs');
const rr = fs.createReadStream('data.txt');
rr.on('readable', () => {
 console.log(`读取的数据${rr.read()}`);
});
rr.on('end', () => {
 console.log('结束');
});
```

通常情况下， readable.pipe() 和 data事件的机制比 readable 事件更容易理解。处理 readable 事件可能造成吞吐量升高。

如果同时使用 readable 事件 和 data 事件，则 readable 事件会优先控制流，也就是说，当调用 stream.read() 时才会触发 data 事件。 readableFlowing 属性会变成 false。

当移除 readable 事件时，如果存在data事件监听器，则流会开始流动，也就是说，无须调用stream.resume() 也会触发data事件。

7. resume事件

调用 stream.resume()并且readsFlowing不为true时，将发出resume事件。

## stream.Readable 类方法

stream.Readable类包含以下常用的方法：

1. destroy

readable.destroy([error]) 方法用于销毁流，并触发 error 事件 和 close 事件. 调用后，可读流将释放所有的内部资源，且忽视后续的push()调用。

实现流时不应该重写这个方法，而是重写readable._destroy()

2. isPaused

readable.isPaused()方法用于返回可读流当前的操纵状态。主要用于 readable.pipe() 底层的机制，大多数情况下无须直接使用该方法

```js
const readable = new stream.Readable();

readable.isPaused(); // === false
readable.pause();
readable.isPaused(); // === true
readable.resume();
readable.isPaused(); // ==== false
```

3. pause 与 resume

readable.pause() 方法使流动模式的流停止触发 data 事件，并切换到流动模式。任何可用的数据都会保留在内部缓存中。

相对的, readable.resume() 将被暂停⏸️的可读流恢复触发data事件，并将流切换到流动模式。

```js
const fs = require('fs');

const readable = fs.createReadStream('data.txt');
readable.on('data', (chunk) => {
 console.log(`接收到${chunk.length}字节的数据`);
 // 暂停
 readable.pause();

 console.log('暂停一秒');
 setTimeout(() => {
  console.log('数据重新开始流动');
  // 继续
  readable.resume();
 },1000);
});

readable.on('end', () => {
 console.log('结束');
});
```

4. pipe

readable.pipe(destination[, options]) 方法用于绑定 可写流 到 可读流，将 可读流 自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。

数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。

将可读流的所有数据通过管道推送到 write-data.txt 文件

```js
const fs = require('fs')

const readable = fs.createReadStream('data.txt');

const writable = fs.createWriteStream('write-data.txt');

// readable 的所有数据都推送到 write-data.txt
readable.pipe(writable);
```

可以在单个可读流上绑定多个可写流。

```js
readable.pipe() // 会返回目标流的引用，这样就可以对流进行链式的管道操作。

const fs = require('fs');
const zlib = require('zlib');

const readable = fs.createReadStream('data.txt');
const gzip = zlib.createGzip();
const writable2 = fs.createWriteStream('write-data.txt.gz');

// 在单个可读流上绑定多个可写流
readable.pipe(gzip).pipe(writable2);
```

默认情况下，当来源可读流触发 end 事件时，目标可写流 也会调用 stream.end() 结束写入。

若要禁用这种默认行为，end选项应设为 false ，这样目标流就回保持打开。

```js
reader.pipe(writer, { end: false });
reader.on('end', () => {
 writer.end('结束');
});
```

如果可读流发生错误🙅🙅‍♂️，目标可写流不会自动关闭，需要手动关闭所有流以避免内存泄漏。

process.stderr 和 process.stdout 可写的流在 Node.js 进程退出之前永远不会关闭，无论指定的选项如何。

5. read

readable.read([size]) 方法用于从内部缓冲拉取并返回数据。其中，size 指定要读取的数据的字节数。如果没有指定 size 参数，则返回内部缓冲中的所有数据。

该方法如果没有可读的数据，则返回null。默认情况下，readable.read() 返回的数据是 Buffer对象，除非使用 readable.setEncoding() 指定字符编码或流 处于对象模式。

如果可读的数据不足size 个字节，则返回内部缓冲剩余的数据，如果流已经结束则 返回null

readable.read() 应该只对 处于暂停模式的可读流调用。在流动模式中， readable.read() 会自动调用直到内部缓冲的数据完全耗尽。

如果 readable.read() 返回一个数据块，则data 事件也会触发。

end事件触发后再调用 stream.read([size]) 会返回null，不会抛出错误。

```js
const fs = require('fs');
const readable = fs.createReadStream('data.txt');

// 设置字符编码
readable.setEncoding('utf-8');

// 读取数据
readable.on('readable', () => {
 let chunk;
 while (null !== (chunk = readable.read(10))) {
  console.log(`接收到${chunk.length}字节的数据`);
  console.log(`接收到的数据是：${chunk}`);
 }
})

readable.on('end', () =>{
 console.log('结束')
})
```

使用 readable.read() 处理数据时，while 循环是必需的。只有在 readable.read() 返回 null 之后，才会发生 readable 事件；readable.setEncoding() 用于设置字符编码。默认情况下没有设置字符编码，流数据返回的是Buffer对象。如果设置了字符编码，则流数据返回指定编码的字符串。

调用 readable.setEncoding('utf-8')会将数据解析为UTF-8数据，并返回字符串。

调用 readable.setEncoding('hex')则会将数据编码成 十六进制字符串。

6. readable.unpipe([destination])

解绑之前使用stream.pipe()绑定的可写流。

如果没有指定目标可写流，则解绑所有管道，如果指定了流目标可写流，但它没有建立管道，则不起作用。

```js
const fs = require('fs');

const readable = fs.createReadStream('data.txt');

const writable = fs.createWriteStream('write-data.txt');

// readable 的所有数据都推送到 write-data.txt
readable.pipe(writable);

setTimeout(() => {
 console.log('停止写入数据');
 readable.unpipe(writable);
 console.log('收到关闭文件流');
 writable.end();
}, 3);
```


## 异步迭代器

可读流中提供了异步迭代器的使用

```js
const fs = require('fs');

async function print(readable) {
 readable.setEncoding('utf8');
 let data = '';
 // 迭代器
 for await (const k of readable) {
  data += k;
 }
 console.log(data);
}

print(fs.createReadStream('file')).catch(console.log);
```

如果循环以break 或 throw终止，则流将被销毁。

迭代流将完全销毁流，并以大小等于 highWaterMark选项的块读取流。

如果文件的数据少于64kb，则数据将位于单个块中，因为没有为 fs.createReadStream() 提供 highWaterMark 选项。

## 两种读取模式

可读流 运作于 流动模式 flowing 或 暂停模式 paused 两种模式之一。

在流动模式中，数据自动从底层系统读取，并通过 EventEmitter 接口的事件尽可能快地被提供给应用程序。

在暂停模式中，必须显式调用 stream.read() 读取数据块。

所有可读流都开始于暂停模式，可以通过以下方式切换到流动模式。

添加 data 事件句柄

调用 stream.resume()

调用 stream.pipe()










